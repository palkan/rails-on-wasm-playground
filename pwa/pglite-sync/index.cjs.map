{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type {\n  Extension,\n  PGliteInterface,\n  Transaction,\n} from '@electric-sql/pglite'\nimport {\n  ShapeStream,\n  ChangeMessage,\n  isChangeMessage,\n  isControlMessage,\n} from '@electric-sql/client'\nimport type { Offset, ShapeStreamOptions } from '@electric-sql/client'\n\nexport type MapColumnsMap = Record<string, string>\nexport type MapColumnsFn = (message: ChangeMessage<any>) => Record<string, any>\nexport type MapColumns = MapColumnsMap | MapColumnsFn\nexport type ShapeKey = string\n\ntype InsertChangeMessage = ChangeMessage<any> & {\n  headers: { operation: 'insert' }\n}\n\nexport interface SyncShapeToTableOptions {\n  shape: ShapeStreamOptions\n  table: string\n  schema?: string\n  mapColumns?: MapColumns\n  primaryKey: string[]\n  shapeKey?: ShapeKey\n  useCopy?: boolean\n}\n\nexport interface ElectricSyncOptions {\n  debug?: boolean\n  metadataSchema?: string\n}\n\nasync function createPlugin(\n  pg: PGliteInterface,\n  options?: ElectricSyncOptions,\n) {\n  const debug = options?.debug ?? false\n  const metadataSchema = options?.metadataSchema ?? 'electric'\n  const streams: Array<{\n    stream: ShapeStream\n    aborter: AbortController\n  }> = []\n\n  // TODO: keeping an in-memory lock per table such that two\n  // shapes are not synced into one table - this will be\n  // resolved by using reference counting in shadow tables\n  const shapePerTableLock = new Map<string, void>()\n\n  const namespaceObj = {\n    syncShapeToTable: async (options: SyncShapeToTableOptions) => {\n      if (shapePerTableLock.has(options.table)) {\n        throw new Error('Already syncing shape for table ' + options.table)\n      }\n      shapePerTableLock.set(options.table)\n      let shapeSubState: ShapeSubscriptionState | null = null\n\n      // if shapeKey is provided, ensure persistence of shape subscription\n      // state is possible and check if it is already persisted\n      if (options.shapeKey) {\n        shapeSubState = await getShapeSubscriptionState({\n          pg,\n          metadataSchema,\n          shapeKey: options.shapeKey,\n        })\n        if (debug && shapeSubState) {\n          console.log('resuming from shape state', shapeSubState)\n        }\n      }\n\n      // If it's a new subscription there is no state to resume from\n      const isNewSubscription = shapeSubState === null\n\n      // If it's a new subscription we can do a `COPY FROM` to insert the initial data\n      // TODO: in future when we can have multiple shapes on the same table we will need\n      // to make sure we only do a `COPY FROM` on the first shape on the table as they\n      // may overlap and so the insert logic will be wrong.\n      let doCopy = isNewSubscription && options.useCopy\n\n      const aborter = new AbortController()\n      if (options.shape.signal) {\n        // we new to have our own aborter to be able to abort the stream\n        // but still accept the signal from the user\n        options.shape.signal.addEventListener('abort', () => aborter.abort(), {\n          once: true,\n        })\n      }\n      const stream = new ShapeStream({\n        ...options.shape,\n        ...(shapeSubState ?? {}),\n        signal: aborter.signal,\n      })\n\n      // TODO: this aggregates all messages in memory until an\n      // up-to-date message is received, which is not viable for\n      // _very_ large shapes - either we should commit batches to\n      // a temporary table and copy over the transactional result\n      // or use a separate connection to hold a long transaction\n      let messageAggregator: ChangeMessage<any>[] = []\n      let truncateNeeded = false\n\n      stream.subscribe(async (messages) => {\n        if (debug) console.log('sync messages received', messages)\n\n        for (const message of messages) {\n          // accumulate change messages for committing all at once\n          if (isChangeMessage(message)) {\n            messageAggregator.push(message)\n            continue\n          }\n\n          // perform actual DB operations upon receiving control messages\n          if (!isControlMessage(message)) continue\n          switch (message.headers.control) {\n            // mark table as needing truncation before next batch commit\n            case 'must-refetch':\n              if (debug) console.log('refetching shape')\n              truncateNeeded = true\n              messageAggregator = []\n\n              break\n\n            // perform all accumulated changes and store stream state\n            case 'up-to-date':\n              await pg.transaction(async (tx) => {\n                if (debug) console.log('up-to-date, committing all messages')\n\n                // Set the syncing flag to true during this transaction so that\n                // user defined triggers on the table are able to chose how to run\n                // during a sync\n                tx.exec(`SET LOCAL ${metadataSchema}.syncing = true;`)\n\n                if (truncateNeeded) {\n                  truncateNeeded = false\n                  // TODO: sync into shadow table and reference count\n                  // for now just clear the whole table - will break\n                  // cases with multiple shapes on the same table\n                  await tx.exec(`DELETE FROM ${options.table};`)\n                  if (options.shapeKey) {\n                    await deleteShapeSubscriptionState({\n                      pg: tx,\n                      metadataSchema,\n                      shapeKey: options.shapeKey,\n                    })\n                  }\n                }\n\n                if (doCopy) {\n                  // We can do a `COPY FROM` to insert the initial data\n                  // Split messageAggregator into initial inserts and remaining messages\n                  const initialInserts: InsertChangeMessage[] = []\n                  const remainingMessages: ChangeMessage<any>[] = []\n                  let foundNonInsert = false\n                  for (const message of messageAggregator) {\n                    if (\n                      !foundNonInsert &&\n                      message.headers.operation === 'insert'\n                    ) {\n                      initialInserts.push(message as InsertChangeMessage)\n                    } else {\n                      foundNonInsert = true\n                      remainingMessages.push(message)\n                    }\n                  }\n                  if (initialInserts.length > 0) {\n                    // As `COPY FROM` doesn't trigger a NOTIFY, we pop\n                    // the last insert message and and add it to the be beginning\n                    // of the remaining messages to be applied after the `COPY FROM`\n                    remainingMessages.unshift(initialInserts.pop()!)\n                  }\n                  messageAggregator = remainingMessages\n\n                  // Do the `COPY FROM` with initial inserts\n                  if (initialInserts.length > 0) {\n                    applyMessagesToTableWithCopy({\n                      pg: tx,\n                      table: options.table,\n                      schema: options.schema,\n                      messages: initialInserts as InsertChangeMessage[],\n                      mapColumns: options.mapColumns,\n                      primaryKey: options.primaryKey,\n                      debug,\n                    })\n                    // We don't want to do a `COPY FROM` again after that\n                    doCopy = false\n                  }\n                }\n\n                for (const changeMessage of messageAggregator) {\n                  await applyMessageToTable({\n                    pg: tx,\n                    table: options.table,\n                    schema: options.schema,\n                    message: changeMessage,\n                    mapColumns: options.mapColumns,\n                    primaryKey: options.primaryKey,\n                    debug,\n                  })\n                }\n\n                if (\n                  options.shapeKey &&\n                  messageAggregator.length > 0 &&\n                  stream.shapeId !== undefined\n                ) {\n                  await updateShapeSubscriptionState({\n                    pg: tx,\n                    metadataSchema,\n                    shapeKey: options.shapeKey,\n                    shapeId: stream.shapeId,\n                    lastOffset:\n                      messageAggregator[messageAggregator.length - 1].offset,\n                  })\n                }\n              })\n              messageAggregator = []\n              break\n          }\n        }\n      })\n\n      streams.push({\n        stream,\n        aborter,\n      })\n      const unsubscribe = () => {\n        stream.unsubscribeAll()\n        aborter.abort()\n        shapePerTableLock.delete(options.table)\n      }\n      return {\n        unsubscribe,\n        get isUpToDate() {\n          return stream.isUpToDate\n        },\n        get shapeId() {\n          return stream.shapeId\n        },\n        subscribeOnceToUpToDate: (\n          cb: () => void,\n          error: (err: Error) => void,\n        ) => {\n          return stream.subscribeOnceToUpToDate(cb, error)\n        },\n        unsubscribeAllUpToDateSubscribers: () => {\n          stream.unsubscribeAllUpToDateSubscribers()\n        },\n      }\n    },\n  }\n\n  const close = async () => {\n    for (const { stream, aborter } of streams) {\n      stream.unsubscribeAll()\n      aborter.abort()\n    }\n  }\n\n  const init = async () => {\n    await migrateShapeMetadataTables({\n      pg,\n      metadataSchema,\n    })\n  }\n\n  return {\n    namespaceObj,\n    close,\n    init,\n  }\n}\n\nexport function electricSync(options?: ElectricSyncOptions) {\n  return {\n    name: 'ElectricSQL Sync',\n    setup: async (pg: PGliteInterface) => {\n      const { namespaceObj, close, init } = await createPlugin(pg, options)\n      return {\n        namespaceObj,\n        close,\n        init,\n      }\n    },\n  } satisfies Extension\n}\n\nfunction doMapColumns(\n  mapColumns: MapColumns,\n  message: ChangeMessage<any>,\n): Record<string, any> {\n  if (typeof mapColumns === 'function') {\n    return mapColumns(message)\n  } else {\n    const mappedColumns: Record<string, any> = {}\n    for (const [key, value] of Object.entries(mapColumns)) {\n      mappedColumns[key] = message.value[value]\n    }\n    return mappedColumns\n  }\n}\n\ninterface ApplyMessageToTableOptions {\n  pg: PGliteInterface | Transaction\n  table: string\n  schema?: string\n  message: ChangeMessage<any>\n  mapColumns?: MapColumns\n  primaryKey: string[]\n  debug: boolean\n}\n\nasync function applyMessageToTable({\n  pg,\n  table,\n  schema = 'public',\n  message,\n  mapColumns,\n  primaryKey,\n  debug,\n}: ApplyMessageToTableOptions) {\n  const data = mapColumns ? doMapColumns(mapColumns, message) : message.value\n\n  switch (message.headers.operation) {\n    case 'insert': {\n      if (debug) console.log('inserting', data)\n      const columns = Object.keys(data)\n      return await pg.query(\n        `\n            INSERT INTO \"${schema}\".\"${table}\"\n            (${columns.map((s) => '\"' + s + '\"').join(', ')})\n            VALUES\n            (${columns.map((_v, i) => '$' + (i + 1)).join(', ')})\n          `,\n        columns.map((column) => data[column]),\n      )\n    }\n\n    case 'update': {\n      if (debug) console.log('updating', data)\n      const columns = Object.keys(data).filter(\n        // we don't update the primary key, they are used to identify the row\n        (column) => !primaryKey.includes(column),\n      )\n      if (columns.length === 0) return // nothing to update\n      return await pg.query(\n        `\n            UPDATE \"${schema}\".\"${table}\"\n            SET ${columns\n              .map((column, i) => '\"' + column + '\" = $' + (i + 1))\n              .join(', ')}\n            WHERE ${primaryKey\n              .map(\n                (column, i) =>\n                  '\"' + column + '\" = $' + (columns.length + i + 1),\n              )\n              .join(' AND ')}\n          `,\n        [\n          ...columns.map((column) => data[column]),\n          ...primaryKey.map((column) => data[column]),\n        ],\n      )\n    }\n\n    case 'delete': {\n      if (debug) console.log('deleting', data)\n      return await pg.query(\n        `\n            DELETE FROM \"${schema}\".\"${table}\"\n            WHERE ${primaryKey\n              .map((column, i) => '\"' + column + '\" = $' + (i + 1))\n              .join(' AND ')}\n          `,\n        [...primaryKey.map((column) => data[column])],\n      )\n    }\n  }\n}\n\ninterface ApplyMessagesToTableWithCopyOptions {\n  pg: PGliteInterface | Transaction\n  table: string\n  schema?: string\n  messages: InsertChangeMessage[]\n  mapColumns?: MapColumns\n  primaryKey: string[]\n  debug: boolean\n}\n\nasync function applyMessagesToTableWithCopy({\n  pg,\n  table,\n  schema = 'public',\n  messages,\n  mapColumns,\n  debug,\n}: ApplyMessagesToTableWithCopyOptions) {\n  if (debug) console.log('applying messages with COPY')\n\n  // Map the messages to the data to be inserted\n  const data: Record<string, any>[] = messages.map((message) =>\n    mapColumns ? doMapColumns(mapColumns, message) : message.value,\n  )\n\n  // Get column names from the first message\n  const columns = Object.keys(data[0])\n\n  // Create CSV data\n  const csvData = data\n    .map((message) => {\n      return columns\n        .map((column) => {\n          const value = message[column]\n          // Escape double quotes and wrap in quotes if necessary\n          if (\n            typeof value === 'string' &&\n            (value.includes(',') || value.includes('\"') || value.includes('\\n'))\n          ) {\n            return `\"${value.replace(/\"/g, '\"\"')}\"`\n          }\n          return value === null ? '\\\\N' : value\n        })\n        .join(',')\n    })\n    .join('\\n')\n  const csvBlob = new Blob([csvData], { type: 'text/csv' })\n\n  // Perform COPY FROM\n  await pg.query(\n    `\n      COPY \"${schema}\".\"${table}\" (${columns.map((c) => `\"${c}\"`).join(', ')})\n      FROM '/dev/blob'\n      WITH (FORMAT csv, NULL '\\\\N')\n    `,\n    [],\n    {\n      blob: csvBlob,\n    },\n  )\n\n  if (debug) console.log(`Inserted ${messages.length} rows using COPY`)\n}\n\ninterface GetShapeSubscriptionStateOptions {\n  pg: PGliteInterface | Transaction\n  metadataSchema: string\n  shapeKey: ShapeKey\n}\n\ntype ShapeSubscriptionState = Pick<ShapeStreamOptions, 'shapeId' | 'offset'>\n\nasync function getShapeSubscriptionState({\n  pg,\n  metadataSchema,\n  shapeKey,\n}: GetShapeSubscriptionStateOptions): Promise<ShapeSubscriptionState | null> {\n  const result = await pg.query<{ shape_id: string; last_offset: string }>(\n    `\n    SELECT shape_id, last_offset\n    FROM ${subscriptionMetadataTableName(metadataSchema)}\n    WHERE shape_key = $1\n  `,\n    [shapeKey],\n  )\n\n  if (result.rows.length === 0) return null\n\n  const { shape_id: shapeId, last_offset: offset } = result.rows[0]\n  return {\n    shapeId,\n    offset: offset as Offset,\n  }\n}\n\ninterface UpdateShapeSubscriptionStateOptions {\n  pg: PGliteInterface | Transaction\n  metadataSchema: string\n  shapeKey: ShapeKey\n  shapeId: string\n  lastOffset: Offset\n}\n\nasync function updateShapeSubscriptionState({\n  pg,\n  metadataSchema,\n  shapeKey,\n  shapeId,\n  lastOffset,\n}: UpdateShapeSubscriptionStateOptions) {\n  await pg.query(\n    `\n    INSERT INTO ${subscriptionMetadataTableName(metadataSchema)} (shape_key, shape_id, last_offset)\n    VALUES ($1, $2, $3)\n    ON CONFLICT(shape_key)\n    DO UPDATE SET\n      shape_id = EXCLUDED.shape_id,\n      last_offset = EXCLUDED.last_offset;\n  `,\n    [shapeKey, shapeId, lastOffset],\n  )\n}\n\ninterface DeleteShapeSubscriptionStateOptions {\n  pg: PGliteInterface | Transaction\n  metadataSchema: string\n  shapeKey: ShapeKey\n}\n\nasync function deleteShapeSubscriptionState({\n  pg,\n  metadataSchema,\n  shapeKey,\n}: DeleteShapeSubscriptionStateOptions) {\n  await pg.query(\n    `DELETE FROM ${subscriptionMetadataTableName(metadataSchema)} WHERE shape_key = $1`,\n    [shapeKey],\n  )\n}\n\ninterface MigrateShapeMetadataTablesOptions {\n  pg: PGliteInterface | Transaction\n  metadataSchema: string\n}\n\nasync function migrateShapeMetadataTables({\n  pg,\n  metadataSchema,\n}: MigrateShapeMetadataTablesOptions) {\n  await pg.exec(\n    `\n    SET ${metadataSchema}.syncing = false;\n    CREATE SCHEMA IF NOT EXISTS \"${metadataSchema}\";\n    CREATE TABLE IF NOT EXISTS ${subscriptionMetadataTableName(metadataSchema)} (\n      shape_key TEXT PRIMARY KEY,\n      shape_id TEXT NOT NULL,\n      last_offset TEXT NOT NULL\n    );\n    `,\n  )\n}\n\nfunction subscriptionMetadataTableName(metadatSchema: string) {\n  return `\"${metadatSchema}\".\"${subscriptionTableName}\"`\n}\n\nconst subscriptionTableName = `shape_subscriptions_metadata`\n"],"mappings":"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","names":["src_exports","__export","electricSync","__toCommonJS","import_client","createPlugin","pg","options","debug","metadataSchema","streams","shapePerTableLock","shapeSubState","getShapeSubscriptionState","doCopy","aborter","stream","messageAggregator","truncateNeeded","messages","message","tx","deleteShapeSubscriptionState","initialInserts","remainingMessages","foundNonInsert","applyMessagesToTableWithCopy","changeMessage","applyMessageToTable","updateShapeSubscriptionState","cb","error","migrateShapeMetadataTables","namespaceObj","close","init","doMapColumns","mapColumns","mappedColumns","key","value","table","schema","primaryKey","data","columns","s","_v","column","i","csvData","csvBlob","c","shapeKey","result","subscriptionMetadataTableName","shapeId","offset","lastOffset","metadatSchema","subscriptionTableName"]}